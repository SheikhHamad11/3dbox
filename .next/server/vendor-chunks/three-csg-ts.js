"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-csg-ts";
exports.ids = ["vendor-chunks/three-csg-ts"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/CSG.js":
/*!**************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/CSG.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSG: () => (/* binding */ CSG)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _NBuf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NBuf */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/NBuf.js\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Node */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Node.js\");\n/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polygon */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Polygon.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Vector.js\");\n/* harmony import */ var _Vertex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Vertex */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Vertex.js\");\n\n\n\n\n\n\n/**\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n */\nclass CSG {\n    constructor() {\n        this.polygons = [];\n    }\n    static fromPolygons(polygons) {\n        const csg = new CSG();\n        csg.polygons = polygons;\n        return csg;\n    }\n    static fromGeometry(geom, objectIndex) {\n        let polys = [];\n        const posattr = geom.attributes.position;\n        const normalattr = geom.attributes.normal;\n        const uvattr = geom.attributes.uv;\n        const colorattr = geom.attributes.color;\n        const grps = geom.groups;\n        let index;\n        if (geom.index) {\n            index = geom.index.array;\n        }\n        else {\n            index = new Uint16Array((posattr.array.length / posattr.itemSize) | 0);\n            for (let i = 0; i < index.length; i++)\n                index[i] = i;\n        }\n        const triCount = (index.length / 3) | 0;\n        polys = new Array(triCount);\n        for (let i = 0, pli = 0, l = index.length; i < l; i += 3, pli++) {\n            const vertices = new Array(3);\n            for (let j = 0; j < 3; j++) {\n                const vi = index[i + j];\n                const vp = vi * 3;\n                const vt = vi * 2;\n                const x = posattr.array[vp];\n                const y = posattr.array[vp + 1];\n                const z = posattr.array[vp + 2];\n                const nx = normalattr.array[vp];\n                const ny = normalattr.array[vp + 1];\n                const nz = normalattr.array[vp + 2];\n                const u = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt];\n                const v = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt + 1];\n                vertices[j] = new _Vertex__WEBPACK_IMPORTED_MODULE_4__.Vertex(new _Vector__WEBPACK_IMPORTED_MODULE_3__.Vector(x, y, z), new _Vector__WEBPACK_IMPORTED_MODULE_3__.Vector(nx, ny, nz), new _Vector__WEBPACK_IMPORTED_MODULE_3__.Vector(u, v, 0), colorattr &&\n                    new _Vector__WEBPACK_IMPORTED_MODULE_3__.Vector(colorattr.array[vp], colorattr.array[vp + 1], colorattr.array[vp + 2]));\n            }\n            if (objectIndex === undefined && grps && grps.length > 0) {\n                for (const grp of grps) {\n                    if (i >= grp.start && i < grp.start + grp.count) {\n                        polys[pli] = new _Polygon__WEBPACK_IMPORTED_MODULE_2__.Polygon(vertices, grp.materialIndex);\n                    }\n                }\n            }\n            else {\n                polys[pli] = new _Polygon__WEBPACK_IMPORTED_MODULE_2__.Polygon(vertices, objectIndex);\n            }\n        }\n        return CSG.fromPolygons(polys.filter((p) => !Number.isNaN(p.plane.normal.x)));\n    }\n    static toGeometry(csg, toMatrix) {\n        let triCount = 0;\n        const ps = csg.polygons;\n        for (const p of ps) {\n            triCount += p.vertices.length - 2;\n        }\n        const geom = new three__WEBPACK_IMPORTED_MODULE_5__.BufferGeometry();\n        const vertices = new _NBuf__WEBPACK_IMPORTED_MODULE_0__.NBuf3(triCount * 3 * 3);\n        const normals = new _NBuf__WEBPACK_IMPORTED_MODULE_0__.NBuf3(triCount * 3 * 3);\n        const uvs = new _NBuf__WEBPACK_IMPORTED_MODULE_0__.NBuf2(triCount * 2 * 3);\n        let colors;\n        const grps = [];\n        const dgrp = [];\n        for (const p of ps) {\n            const pvs = p.vertices;\n            const pvlen = pvs.length;\n            if (p.shared !== undefined) {\n                if (!grps[p.shared])\n                    grps[p.shared] = [];\n            }\n            if (pvlen && pvs[0].color !== undefined) {\n                if (!colors)\n                    colors = new _NBuf__WEBPACK_IMPORTED_MODULE_0__.NBuf3(triCount * 3 * 3);\n            }\n            for (let j = 3; j <= pvlen; j++) {\n                const grp = p.shared === undefined ? dgrp : grps[p.shared];\n                grp.push(vertices.top / 3, vertices.top / 3 + 1, vertices.top / 3 + 2);\n                vertices.write(pvs[0].pos);\n                vertices.write(pvs[j - 2].pos);\n                vertices.write(pvs[j - 1].pos);\n                normals.write(pvs[0].normal);\n                normals.write(pvs[j - 2].normal);\n                normals.write(pvs[j - 1].normal);\n                if (uvs) {\n                    uvs.write(pvs[0].uv);\n                    uvs.write(pvs[j - 2].uv);\n                    uvs.write(pvs[j - 1].uv);\n                }\n                if (colors) {\n                    colors.write(pvs[0].color);\n                    colors.write(pvs[j - 2].color);\n                    colors.write(pvs[j - 1].color);\n                }\n            }\n        }\n        geom.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_5__.BufferAttribute(vertices.array, 3));\n        geom.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_5__.BufferAttribute(normals.array, 3));\n        uvs && geom.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_5__.BufferAttribute(uvs.array, 2));\n        colors && geom.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_5__.BufferAttribute(colors.array, 3));\n        for (let gi = 0; gi < grps.length; gi++) {\n            if (grps[gi] === undefined) {\n                grps[gi] = [];\n            }\n        }\n        if (grps.length) {\n            let index = [];\n            let gbase = 0;\n            for (let gi = 0; gi < grps.length; gi++) {\n                geom.addGroup(gbase, grps[gi].length, gi);\n                gbase += grps[gi].length;\n                index = index.concat(grps[gi]);\n            }\n            geom.addGroup(gbase, dgrp.length, grps.length);\n            index = index.concat(dgrp);\n            geom.setIndex(index);\n        }\n        const inv = new three__WEBPACK_IMPORTED_MODULE_5__.Matrix4().copy(toMatrix).invert();\n        geom.applyMatrix4(inv);\n        geom.computeBoundingSphere();\n        geom.computeBoundingBox();\n        return geom;\n    }\n    static fromMesh(mesh, objectIndex) {\n        const csg = CSG.fromGeometry(mesh.geometry, objectIndex);\n        const ttvv0 = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const tmpm3 = new three__WEBPACK_IMPORTED_MODULE_5__.Matrix3();\n        tmpm3.getNormalMatrix(mesh.matrix);\n        for (let i = 0; i < csg.polygons.length; i++) {\n            const p = csg.polygons[i];\n            for (let j = 0; j < p.vertices.length; j++) {\n                const v = p.vertices[j];\n                v.pos.copy(ttvv0.copy(v.pos.toVector3()).applyMatrix4(mesh.matrix));\n                v.normal.copy(ttvv0.copy(v.normal.toVector3()).applyMatrix3(tmpm3));\n            }\n        }\n        return csg;\n    }\n    static toMesh(csg, toMatrix, toMaterial) {\n        const geom = CSG.toGeometry(csg, toMatrix);\n        const m = new three__WEBPACK_IMPORTED_MODULE_5__.Mesh(geom, toMaterial);\n        m.matrix.copy(toMatrix);\n        m.matrix.decompose(m.position, m.quaternion, m.scale);\n        m.rotation.setFromQuaternion(m.quaternion);\n        m.updateMatrixWorld();\n        m.castShadow = m.receiveShadow = true;\n        return m;\n    }\n    static union(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.union(csgB), meshA.matrix, meshA.material);\n    }\n    static subtract(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.subtract(csgB), meshA.matrix, meshA.material);\n    }\n    static intersect(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.intersect(csgB), meshA.matrix, meshA.material);\n    }\n    clone() {\n        const csg = new CSG();\n        csg.polygons = this.polygons\n            .map((p) => p.clone())\n            .filter((p) => Number.isFinite(p.plane.w));\n        return csg;\n    }\n    toPolygons() {\n        return this.polygons;\n    }\n    union(csg) {\n        const a = new _Node__WEBPACK_IMPORTED_MODULE_1__.Node(this.clone().polygons);\n        const b = new _Node__WEBPACK_IMPORTED_MODULE_1__.Node(csg.clone().polygons);\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    subtract(csg) {\n        const a = new _Node__WEBPACK_IMPORTED_MODULE_1__.Node(this.clone().polygons);\n        const b = new _Node__WEBPACK_IMPORTED_MODULE_1__.Node(csg.clone().polygons);\n        a.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    intersect(csg) {\n        const a = new _Node__WEBPACK_IMPORTED_MODULE_1__.Node(this.clone().polygons);\n        const b = new _Node__WEBPACK_IMPORTED_MODULE_1__.Node(csg.clone().polygons);\n        a.invert();\n        b.clipTo(a);\n        b.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    // Return a new CSG solid with solid and empty space switched. This solid is\n    // not modified.\n    inverse() {\n        const csg = this.clone();\n        for (const p of csg.polygons) {\n            p.flip();\n        }\n        return csg;\n    }\n    toMesh(toMatrix, toMaterial) {\n        return CSG.toMesh(this, toMatrix, toMaterial);\n    }\n    toGeometry(toMatrix) {\n        return CSG.toGeometry(this, toMatrix);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vQ1NHLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEY7QUFDcEQ7QUFDUjtBQUNNO0FBQ0Y7QUFDQTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQ0FBTSxLQUFLLDJDQUFNLGVBQWUsMkNBQU0sa0JBQWtCLDJDQUFNO0FBQ2hHLHdCQUF3QiwyQ0FBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2Q0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBYztBQUN2Qyw2QkFBNkIsd0NBQUs7QUFDbEMsNEJBQTRCLHdDQUFLO0FBQ2pDLHdCQUF3Qix3Q0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0NBQUs7QUFDdEM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlO0FBQ3pELHdDQUF3QyxrREFBZTtBQUN2RCwyQ0FBMkMsa0RBQWU7QUFDMUQsaURBQWlELGtEQUFlO0FBQ2hFLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQU87QUFDakMsMEJBQTBCLDBDQUFPO0FBQ2pDO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1Q0FBSTtBQUMxQixzQkFBc0IsdUNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUFJO0FBQzFCLHNCQUFzQix1Q0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUFJO0FBQzFCLHNCQUFzQix1Q0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzNkX2JveF9kZXNpZ24vLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vQ1NHLmpzP2QyZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgTWF0cml4MywgTWF0cml4NCwgTWVzaCwgVmVjdG9yMywgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBOQnVmMiwgTkJ1ZjMgfSBmcm9tICcuL05CdWYnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZSc7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9Qb2x5Z29uJztcbmltcG9ydCB7IFZlY3RvciB9IGZyb20gJy4vVmVjdG9yJztcbmltcG9ydCB7IFZlcnRleCB9IGZyb20gJy4vVmVydGV4Jztcbi8qKlxuICogSG9sZHMgYSBiaW5hcnkgc3BhY2UgcGFydGl0aW9uIHRyZWUgcmVwcmVzZW50aW5nIGEgM0Qgc29saWQuIFR3byBzb2xpZHMgY2FuXG4gKiBiZSBjb21iaW5lZCB1c2luZyB0aGUgYHVuaW9uKClgLCBgc3VidHJhY3QoKWAsIGFuZCBgaW50ZXJzZWN0KClgIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDU0cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBvbHlnb25zID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUG9seWdvbnMocG9seWdvbnMpIHtcbiAgICAgICAgY29uc3QgY3NnID0gbmV3IENTRygpO1xuICAgICAgICBjc2cucG9seWdvbnMgPSBwb2x5Z29ucztcbiAgICAgICAgcmV0dXJuIGNzZztcbiAgICB9XG4gICAgc3RhdGljIGZyb21HZW9tZXRyeShnZW9tLCBvYmplY3RJbmRleCkge1xuICAgICAgICBsZXQgcG9seXMgPSBbXTtcbiAgICAgICAgY29uc3QgcG9zYXR0ciA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgbm9ybWFsYXR0ciA9IGdlb20uYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICAgIGNvbnN0IHV2YXR0ciA9IGdlb20uYXR0cmlidXRlcy51djtcbiAgICAgICAgY29uc3QgY29sb3JhdHRyID0gZ2VvbS5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgICBjb25zdCBncnBzID0gZ2VvbS5ncm91cHM7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZ2VvbS5pbmRleC5hcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gbmV3IFVpbnQxNkFycmF5KChwb3NhdHRyLmFycmF5Lmxlbmd0aCAvIHBvc2F0dHIuaXRlbVNpemUpIHwgMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGluZGV4W2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmlDb3VudCA9IChpbmRleC5sZW5ndGggLyAzKSB8IDA7XG4gICAgICAgIHBvbHlzID0gbmV3IEFycmF5KHRyaUNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBsaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIHBsaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmkgPSBpbmRleFtpICsgal07XG4gICAgICAgICAgICAgICAgY29uc3QgdnAgPSB2aSAqIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgdnQgPSB2aSAqIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHBvc2F0dHIuYXJyYXlbdnBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb3NhdHRyLmFycmF5W3ZwICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IHBvc2F0dHIuYXJyYXlbdnAgKyAyXTtcbiAgICAgICAgICAgICAgICBjb25zdCBueCA9IG5vcm1hbGF0dHIuYXJyYXlbdnBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG55ID0gbm9ybWFsYXR0ci5hcnJheVt2cCArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG56ID0gbm9ybWFsYXR0ci5hcnJheVt2cCArIDJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHUgPSB1dmF0dHIgPT09IG51bGwgfHwgdXZhdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1dmF0dHIuYXJyYXlbdnRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB1dmF0dHIgPT09IG51bGwgfHwgdXZhdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1dmF0dHIuYXJyYXlbdnQgKyAxXTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tqXSA9IG5ldyBWZXJ0ZXgobmV3IFZlY3Rvcih4LCB5LCB6KSwgbmV3IFZlY3RvcihueCwgbnksIG56KSwgbmV3IFZlY3Rvcih1LCB2LCAwKSwgY29sb3JhdHRyICYmXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoY29sb3JhdHRyLmFycmF5W3ZwXSwgY29sb3JhdHRyLmFycmF5W3ZwICsgMV0sIGNvbG9yYXR0ci5hcnJheVt2cCArIDJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0SW5kZXggPT09IHVuZGVmaW5lZCAmJiBncnBzICYmIGdycHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZ3JwIG9mIGdycHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gZ3JwLnN0YXJ0ICYmIGkgPCBncnAuc3RhcnQgKyBncnAuY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlzW3BsaV0gPSBuZXcgUG9seWdvbih2ZXJ0aWNlcywgZ3JwLm1hdGVyaWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9seXNbcGxpXSA9IG5ldyBQb2x5Z29uKHZlcnRpY2VzLCBvYmplY3RJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENTRy5mcm9tUG9seWdvbnMocG9seXMuZmlsdGVyKChwKSA9PiAhTnVtYmVyLmlzTmFOKHAucGxhbmUubm9ybWFsLngpKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0dlb21ldHJ5KGNzZywgdG9NYXRyaXgpIHtcbiAgICAgICAgbGV0IHRyaUNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcHMgPSBjc2cucG9seWdvbnM7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwcykge1xuICAgICAgICAgICAgdHJpQ291bnQgKz0gcC52ZXJ0aWNlcy5sZW5ndGggLSAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgTkJ1ZjModHJpQ291bnQgKiAzICogMyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbHMgPSBuZXcgTkJ1ZjModHJpQ291bnQgKiAzICogMyk7XG4gICAgICAgIGNvbnN0IHV2cyA9IG5ldyBOQnVmMih0cmlDb3VudCAqIDIgKiAzKTtcbiAgICAgICAgbGV0IGNvbG9ycztcbiAgICAgICAgY29uc3QgZ3JwcyA9IFtdO1xuICAgICAgICBjb25zdCBkZ3JwID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwcykge1xuICAgICAgICAgICAgY29uc3QgcHZzID0gcC52ZXJ0aWNlcztcbiAgICAgICAgICAgIGNvbnN0IHB2bGVuID0gcHZzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwLnNoYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFncnBzW3Auc2hhcmVkXSlcbiAgICAgICAgICAgICAgICAgICAgZ3Jwc1twLnNoYXJlZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwdmxlbiAmJiBwdnNbMF0uY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghY29sb3JzKVxuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSBuZXcgTkJ1ZjModHJpQ291bnQgKiAzICogMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMzsgaiA8PSBwdmxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JwID0gcC5zaGFyZWQgPT09IHVuZGVmaW5lZCA/IGRncnAgOiBncnBzW3Auc2hhcmVkXTtcbiAgICAgICAgICAgICAgICBncnAucHVzaCh2ZXJ0aWNlcy50b3AgLyAzLCB2ZXJ0aWNlcy50b3AgLyAzICsgMSwgdmVydGljZXMudG9wIC8gMyArIDIpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLndyaXRlKHB2c1swXS5wb3MpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLndyaXRlKHB2c1tqIC0gMl0ucG9zKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy53cml0ZShwdnNbaiAtIDFdLnBvcyk7XG4gICAgICAgICAgICAgICAgbm9ybWFscy53cml0ZShwdnNbMF0ubm9ybWFsKTtcbiAgICAgICAgICAgICAgICBub3JtYWxzLndyaXRlKHB2c1tqIC0gMl0ubm9ybWFsKTtcbiAgICAgICAgICAgICAgICBub3JtYWxzLndyaXRlKHB2c1tqIC0gMV0ubm9ybWFsKTtcbiAgICAgICAgICAgICAgICBpZiAodXZzKSB7XG4gICAgICAgICAgICAgICAgICAgIHV2cy53cml0ZShwdnNbMF0udXYpO1xuICAgICAgICAgICAgICAgICAgICB1dnMud3JpdGUocHZzW2ogLSAyXS51dik7XG4gICAgICAgICAgICAgICAgICAgIHV2cy53cml0ZShwdnNbaiAtIDFdLnV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMud3JpdGUocHZzWzBdLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLndyaXRlKHB2c1tqIC0gMl0uY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMud3JpdGUocHZzW2ogLSAxXS5jb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdlb20uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMuYXJyYXksIDMpKTtcbiAgICAgICAgZ2VvbS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobm9ybWFscy5hcnJheSwgMykpO1xuICAgICAgICB1dnMgJiYgZ2VvbS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh1dnMuYXJyYXksIDIpKTtcbiAgICAgICAgY29sb3JzICYmIGdlb20uc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLmFycmF5LCAzKSk7XG4gICAgICAgIGZvciAobGV0IGdpID0gMDsgZ2kgPCBncnBzLmxlbmd0aDsgZ2krKykge1xuICAgICAgICAgICAgaWYgKGdycHNbZ2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBncnBzW2dpXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncnBzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gW107XG4gICAgICAgICAgICBsZXQgZ2Jhc2UgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgZ2kgPSAwOyBnaSA8IGdycHMubGVuZ3RoOyBnaSsrKSB7XG4gICAgICAgICAgICAgICAgZ2VvbS5hZGRHcm91cChnYmFzZSwgZ3Jwc1tnaV0ubGVuZ3RoLCBnaSk7XG4gICAgICAgICAgICAgICAgZ2Jhc2UgKz0gZ3Jwc1tnaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXguY29uY2F0KGdycHNbZ2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlb20uYWRkR3JvdXAoZ2Jhc2UsIGRncnAubGVuZ3RoLCBncnBzLmxlbmd0aCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4LmNvbmNhdChkZ3JwKTtcbiAgICAgICAgICAgIGdlb20uc2V0SW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludiA9IG5ldyBNYXRyaXg0KCkuY29weSh0b01hdHJpeCkuaW52ZXJ0KCk7XG4gICAgICAgIGdlb20uYXBwbHlNYXRyaXg0KGludik7XG4gICAgICAgIGdlb20uY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgICAgIGdlb20uY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU1lc2gobWVzaCwgb2JqZWN0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgY3NnID0gQ1NHLmZyb21HZW9tZXRyeShtZXNoLmdlb21ldHJ5LCBvYmplY3RJbmRleCk7XG4gICAgICAgIGNvbnN0IHR0dnYwID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgdG1wbTMgPSBuZXcgTWF0cml4MygpO1xuICAgICAgICB0bXBtMy5nZXROb3JtYWxNYXRyaXgobWVzaC5tYXRyaXgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzZy5wb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IGNzZy5wb2x5Z29uc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBwLnZlcnRpY2VzW2pdO1xuICAgICAgICAgICAgICAgIHYucG9zLmNvcHkodHR2djAuY29weSh2LnBvcy50b1ZlY3RvcjMoKSkuYXBwbHlNYXRyaXg0KG1lc2gubWF0cml4KSk7XG4gICAgICAgICAgICAgICAgdi5ub3JtYWwuY29weSh0dHZ2MC5jb3B5KHYubm9ybWFsLnRvVmVjdG9yMygpKS5hcHBseU1hdHJpeDModG1wbTMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NnO1xuICAgIH1cbiAgICBzdGF0aWMgdG9NZXNoKGNzZywgdG9NYXRyaXgsIHRvTWF0ZXJpYWwpIHtcbiAgICAgICAgY29uc3QgZ2VvbSA9IENTRy50b0dlb21ldHJ5KGNzZywgdG9NYXRyaXgpO1xuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goZ2VvbSwgdG9NYXRlcmlhbCk7XG4gICAgICAgIG0ubWF0cml4LmNvcHkodG9NYXRyaXgpO1xuICAgICAgICBtLm1hdHJpeC5kZWNvbXBvc2UobS5wb3NpdGlvbiwgbS5xdWF0ZXJuaW9uLCBtLnNjYWxlKTtcbiAgICAgICAgbS5yb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbihtLnF1YXRlcm5pb24pO1xuICAgICAgICBtLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgIG0uY2FzdFNoYWRvdyA9IG0ucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBzdGF0aWMgdW5pb24obWVzaEEsIG1lc2hCKSB7XG4gICAgICAgIGNvbnN0IGNzZ0EgPSBDU0cuZnJvbU1lc2gobWVzaEEpO1xuICAgICAgICBjb25zdCBjc2dCID0gQ1NHLmZyb21NZXNoKG1lc2hCKTtcbiAgICAgICAgcmV0dXJuIENTRy50b01lc2goY3NnQS51bmlvbihjc2dCKSwgbWVzaEEubWF0cml4LCBtZXNoQS5tYXRlcmlhbCk7XG4gICAgfVxuICAgIHN0YXRpYyBzdWJ0cmFjdChtZXNoQSwgbWVzaEIpIHtcbiAgICAgICAgY29uc3QgY3NnQSA9IENTRy5mcm9tTWVzaChtZXNoQSk7XG4gICAgICAgIGNvbnN0IGNzZ0IgPSBDU0cuZnJvbU1lc2gobWVzaEIpO1xuICAgICAgICByZXR1cm4gQ1NHLnRvTWVzaChjc2dBLnN1YnRyYWN0KGNzZ0IpLCBtZXNoQS5tYXRyaXgsIG1lc2hBLm1hdGVyaWFsKTtcbiAgICB9XG4gICAgc3RhdGljIGludGVyc2VjdChtZXNoQSwgbWVzaEIpIHtcbiAgICAgICAgY29uc3QgY3NnQSA9IENTRy5mcm9tTWVzaChtZXNoQSk7XG4gICAgICAgIGNvbnN0IGNzZ0IgPSBDU0cuZnJvbU1lc2gobWVzaEIpO1xuICAgICAgICByZXR1cm4gQ1NHLnRvTWVzaChjc2dBLmludGVyc2VjdChjc2dCKSwgbWVzaEEubWF0cml4LCBtZXNoQS5tYXRlcmlhbCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjc2cgPSBuZXcgQ1NHKCk7XG4gICAgICAgIGNzZy5wb2x5Z29ucyA9IHRoaXMucG9seWdvbnNcbiAgICAgICAgICAgIC5tYXAoKHApID0+IHAuY2xvbmUoKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHApID0+IE51bWJlci5pc0Zpbml0ZShwLnBsYW5lLncpKTtcbiAgICAgICAgcmV0dXJuIGNzZztcbiAgICB9XG4gICAgdG9Qb2x5Z29ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9seWdvbnM7XG4gICAgfVxuICAgIHVuaW9uKGNzZykge1xuICAgICAgICBjb25zdCBhID0gbmV3IE5vZGUodGhpcy5jbG9uZSgpLnBvbHlnb25zKTtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBOb2RlKGNzZy5jbG9uZSgpLnBvbHlnb25zKTtcbiAgICAgICAgYS5jbGlwVG8oYik7XG4gICAgICAgIGIuY2xpcFRvKGEpO1xuICAgICAgICBiLmludmVydCgpO1xuICAgICAgICBiLmNsaXBUbyhhKTtcbiAgICAgICAgYi5pbnZlcnQoKTtcbiAgICAgICAgYS5idWlsZChiLmFsbFBvbHlnb25zKCkpO1xuICAgICAgICByZXR1cm4gQ1NHLmZyb21Qb2x5Z29ucyhhLmFsbFBvbHlnb25zKCkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChjc2cpIHtcbiAgICAgICAgY29uc3QgYSA9IG5ldyBOb2RlKHRoaXMuY2xvbmUoKS5wb2x5Z29ucyk7XG4gICAgICAgIGNvbnN0IGIgPSBuZXcgTm9kZShjc2cuY2xvbmUoKS5wb2x5Z29ucyk7XG4gICAgICAgIGEuaW52ZXJ0KCk7XG4gICAgICAgIGEuY2xpcFRvKGIpO1xuICAgICAgICBiLmNsaXBUbyhhKTtcbiAgICAgICAgYi5pbnZlcnQoKTtcbiAgICAgICAgYi5jbGlwVG8oYSk7XG4gICAgICAgIGIuaW52ZXJ0KCk7XG4gICAgICAgIGEuYnVpbGQoYi5hbGxQb2x5Z29ucygpKTtcbiAgICAgICAgYS5pbnZlcnQoKTtcbiAgICAgICAgcmV0dXJuIENTRy5mcm9tUG9seWdvbnMoYS5hbGxQb2x5Z29ucygpKTtcbiAgICB9XG4gICAgaW50ZXJzZWN0KGNzZykge1xuICAgICAgICBjb25zdCBhID0gbmV3IE5vZGUodGhpcy5jbG9uZSgpLnBvbHlnb25zKTtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBOb2RlKGNzZy5jbG9uZSgpLnBvbHlnb25zKTtcbiAgICAgICAgYS5pbnZlcnQoKTtcbiAgICAgICAgYi5jbGlwVG8oYSk7XG4gICAgICAgIGIuaW52ZXJ0KCk7XG4gICAgICAgIGEuY2xpcFRvKGIpO1xuICAgICAgICBiLmNsaXBUbyhhKTtcbiAgICAgICAgYS5idWlsZChiLmFsbFBvbHlnb25zKCkpO1xuICAgICAgICBhLmludmVydCgpO1xuICAgICAgICByZXR1cm4gQ1NHLmZyb21Qb2x5Z29ucyhhLmFsbFBvbHlnb25zKCkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYSBuZXcgQ1NHIHNvbGlkIHdpdGggc29saWQgYW5kIGVtcHR5IHNwYWNlIHN3aXRjaGVkLiBUaGlzIHNvbGlkIGlzXG4gICAgLy8gbm90IG1vZGlmaWVkLlxuICAgIGludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGNzZyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIGNzZy5wb2x5Z29ucykge1xuICAgICAgICAgICAgcC5mbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzZztcbiAgICB9XG4gICAgdG9NZXNoKHRvTWF0cml4LCB0b01hdGVyaWFsKSB7XG4gICAgICAgIHJldHVybiBDU0cudG9NZXNoKHRoaXMsIHRvTWF0cml4LCB0b01hdGVyaWFsKTtcbiAgICB9XG4gICAgdG9HZW9tZXRyeSh0b01hdHJpeCkge1xuICAgICAgICByZXR1cm4gQ1NHLnRvR2VvbWV0cnkodGhpcywgdG9NYXRyaXgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/CSG.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/NBuf.js":
/*!***************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/NBuf.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NBuf2: () => (/* binding */ NBuf2),\n/* harmony export */   NBuf3: () => (/* binding */ NBuf3)\n/* harmony export */ });\nclass NBuf3 {\n    constructor(ct) {\n        this.top = 0;\n        this.array = new Float32Array(ct);\n    }\n    write(v) {\n        this.array[this.top++] = v.x;\n        this.array[this.top++] = v.y;\n        this.array[this.top++] = v.z;\n    }\n}\nclass NBuf2 {\n    constructor(ct) {\n        this.top = 0;\n        this.array = new Float32Array(ct);\n    }\n    write(v) {\n        this.array[this.top++] = v.x;\n        this.array[this.top++] = v.y;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vTkJ1Zi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzNkX2JveF9kZXNpZ24vLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vTkJ1Zi5qcz83MjY4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBOQnVmMyB7XG4gICAgY29uc3RydWN0b3IoY3QpIHtcbiAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdCk7XG4gICAgfVxuICAgIHdyaXRlKHYpIHtcbiAgICAgICAgdGhpcy5hcnJheVt0aGlzLnRvcCsrXSA9IHYueDtcbiAgICAgICAgdGhpcy5hcnJheVt0aGlzLnRvcCsrXSA9IHYueTtcbiAgICAgICAgdGhpcy5hcnJheVt0aGlzLnRvcCsrXSA9IHYuejtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTkJ1ZjIge1xuICAgIGNvbnN0cnVjdG9yKGN0KSB7XG4gICAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY3QpO1xuICAgIH1cbiAgICB3cml0ZSh2KSB7XG4gICAgICAgIHRoaXMuYXJyYXlbdGhpcy50b3ArK10gPSB2Lng7XG4gICAgICAgIHRoaXMuYXJyYXlbdGhpcy50b3ArK10gPSB2Lnk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/NBuf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/Node.js":
/*!***************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/Node.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node)\n/* harmony export */ });\n/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes.\n */\nclass Node {\n    constructor(polygons) {\n        this.plane = null;\n        this.front = null;\n        this.back = null;\n        this.polygons = [];\n        if (polygons)\n            this.build(polygons);\n    }\n    clone() {\n        const node = new Node();\n        node.plane = this.plane && this.plane.clone();\n        node.front = this.front && this.front.clone();\n        node.back = this.back && this.back.clone();\n        node.polygons = this.polygons.map((p) => p.clone());\n        return node;\n    }\n    // Convert solid space to empty space and empty space to solid space.\n    invert() {\n        for (let i = 0; i < this.polygons.length; i++)\n            this.polygons[i].flip();\n        this.plane && this.plane.flip();\n        this.front && this.front.invert();\n        this.back && this.back.invert();\n        const temp = this.front;\n        this.front = this.back;\n        this.back = temp;\n    }\n    // Recursively remove all polygons in `polygons` that are inside this BSP\n    // tree.\n    clipPolygons(polygons) {\n        if (!this.plane)\n            return polygons.slice();\n        let front = new Array(), back = new Array();\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\n        }\n        if (this.front)\n            front = this.front.clipPolygons(front);\n        this.back ? (back = this.back.clipPolygons(back)) : (back = []);\n        return front.concat(back);\n    }\n    // Remove all polygons in this BSP tree that are inside the other BSP tree\n    // `bsp`.\n    clipTo(bsp) {\n        this.polygons = bsp.clipPolygons(this.polygons);\n        if (this.front)\n            this.front.clipTo(bsp);\n        if (this.back)\n            this.back.clipTo(bsp);\n    }\n    // Return a list of all polygons in this BSP tree.\n    allPolygons() {\n        let polygons = this.polygons.slice();\n        if (this.front)\n            polygons = polygons.concat(this.front.allPolygons());\n        if (this.back)\n            polygons = polygons.concat(this.back.allPolygons());\n        return polygons;\n    }\n    // Build a BSP tree out of `polygons`. When called on an existing tree, the\n    // new polygons are filtered down to the bottom of the tree and become new\n    // nodes there. Each set of polygons is partitioned using the first polygon\n    // (no heuristic is used to pick a good split).\n    build(polygons) {\n        if (!polygons.length)\n            return;\n        if (!this.plane)\n            this.plane = polygons[0].plane.clone();\n        const front = [], back = [];\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n        }\n        if (front.length) {\n            if (!this.front)\n                this.front = new Node();\n            this.front.build(front);\n        }\n        if (back.length) {\n            if (!this.back)\n                this.back = new Node();\n            this.back.build(back);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzNkX2JveF9kZXNpZ24vLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vTm9kZS5qcz8zMzliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSG9sZHMgYSBub2RlIGluIGEgQlNQIHRyZWUuIEEgQlNQIHRyZWUgaXMgYnVpbHQgZnJvbSBhIGNvbGxlY3Rpb24gb2YgcG9seWdvbnNcbiAqIGJ5IHBpY2tpbmcgYSBwb2x5Z29uIHRvIHNwbGl0IGFsb25nLiBUaGF0IHBvbHlnb24gKGFuZCBhbGwgb3RoZXIgY29wbGFuYXJcbiAqIHBvbHlnb25zKSBhcmUgYWRkZWQgZGlyZWN0bHkgdG8gdGhhdCBub2RlIGFuZCB0aGUgb3RoZXIgcG9seWdvbnMgYXJlIGFkZGVkIHRvXG4gKiB0aGUgZnJvbnQgYW5kL29yIGJhY2sgc3VidHJlZXMuIFRoaXMgaXMgbm90IGEgbGVhZnkgQlNQIHRyZWUgc2luY2UgdGhlcmUgaXNcbiAqIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gaW50ZXJuYWwgYW5kIGxlYWYgbm9kZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2x5Z29ucykge1xuICAgICAgICB0aGlzLnBsYW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucG9seWdvbnMgPSBbXTtcbiAgICAgICAgaWYgKHBvbHlnb25zKVxuICAgICAgICAgICAgdGhpcy5idWlsZChwb2x5Z29ucyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgbm9kZS5wbGFuZSA9IHRoaXMucGxhbmUgJiYgdGhpcy5wbGFuZS5jbG9uZSgpO1xuICAgICAgICBub2RlLmZyb250ID0gdGhpcy5mcm9udCAmJiB0aGlzLmZyb250LmNsb25lKCk7XG4gICAgICAgIG5vZGUuYmFjayA9IHRoaXMuYmFjayAmJiB0aGlzLmJhY2suY2xvbmUoKTtcbiAgICAgICAgbm9kZS5wb2x5Z29ucyA9IHRoaXMucG9seWdvbnMubWFwKChwKSA9PiBwLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBzb2xpZCBzcGFjZSB0byBlbXB0eSBzcGFjZSBhbmQgZW1wdHkgc3BhY2UgdG8gc29saWQgc3BhY2UuXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9seWdvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnBvbHlnb25zW2ldLmZsaXAoKTtcbiAgICAgICAgdGhpcy5wbGFuZSAmJiB0aGlzLnBsYW5lLmZsaXAoKTtcbiAgICAgICAgdGhpcy5mcm9udCAmJiB0aGlzLmZyb250LmludmVydCgpO1xuICAgICAgICB0aGlzLmJhY2sgJiYgdGhpcy5iYWNrLmludmVydCgpO1xuICAgICAgICBjb25zdCB0ZW1wID0gdGhpcy5mcm9udDtcbiAgICAgICAgdGhpcy5mcm9udCA9IHRoaXMuYmFjaztcbiAgICAgICAgdGhpcy5iYWNrID0gdGVtcDtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcmVtb3ZlIGFsbCBwb2x5Z29ucyBpbiBgcG9seWdvbnNgIHRoYXQgYXJlIGluc2lkZSB0aGlzIEJTUFxuICAgIC8vIHRyZWUuXG4gICAgY2xpcFBvbHlnb25zKHBvbHlnb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5wbGFuZSlcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29ucy5zbGljZSgpO1xuICAgICAgICBsZXQgZnJvbnQgPSBuZXcgQXJyYXkoKSwgYmFjayA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnBsYW5lLnNwbGl0UG9seWdvbihwb2x5Z29uc1tpXSwgZnJvbnQsIGJhY2ssIGZyb250LCBiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcm9udClcbiAgICAgICAgICAgIGZyb250ID0gdGhpcy5mcm9udC5jbGlwUG9seWdvbnMoZnJvbnQpO1xuICAgICAgICB0aGlzLmJhY2sgPyAoYmFjayA9IHRoaXMuYmFjay5jbGlwUG9seWdvbnMoYmFjaykpIDogKGJhY2sgPSBbXSk7XG4gICAgICAgIHJldHVybiBmcm9udC5jb25jYXQoYmFjayk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbGwgcG9seWdvbnMgaW4gdGhpcyBCU1AgdHJlZSB0aGF0IGFyZSBpbnNpZGUgdGhlIG90aGVyIEJTUCB0cmVlXG4gICAgLy8gYGJzcGAuXG4gICAgY2xpcFRvKGJzcCkge1xuICAgICAgICB0aGlzLnBvbHlnb25zID0gYnNwLmNsaXBQb2x5Z29ucyh0aGlzLnBvbHlnb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQpXG4gICAgICAgICAgICB0aGlzLmZyb250LmNsaXBUbyhic3ApO1xuICAgICAgICBpZiAodGhpcy5iYWNrKVxuICAgICAgICAgICAgdGhpcy5iYWNrLmNsaXBUbyhic3ApO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYSBsaXN0IG9mIGFsbCBwb2x5Z29ucyBpbiB0aGlzIEJTUCB0cmVlLlxuICAgIGFsbFBvbHlnb25zKCkge1xuICAgICAgICBsZXQgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zLnNsaWNlKCk7XG4gICAgICAgIGlmICh0aGlzLmZyb250KVxuICAgICAgICAgICAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQodGhpcy5mcm9udC5hbGxQb2x5Z29ucygpKTtcbiAgICAgICAgaWYgKHRoaXMuYmFjaylcbiAgICAgICAgICAgIHBvbHlnb25zID0gcG9seWdvbnMuY29uY2F0KHRoaXMuYmFjay5hbGxQb2x5Z29ucygpKTtcbiAgICAgICAgcmV0dXJuIHBvbHlnb25zO1xuICAgIH1cbiAgICAvLyBCdWlsZCBhIEJTUCB0cmVlIG91dCBvZiBgcG9seWdvbnNgLiBXaGVuIGNhbGxlZCBvbiBhbiBleGlzdGluZyB0cmVlLCB0aGVcbiAgICAvLyBuZXcgcG9seWdvbnMgYXJlIGZpbHRlcmVkIGRvd24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgdHJlZSBhbmQgYmVjb21lIG5ld1xuICAgIC8vIG5vZGVzIHRoZXJlLiBFYWNoIHNldCBvZiBwb2x5Z29ucyBpcyBwYXJ0aXRpb25lZCB1c2luZyB0aGUgZmlyc3QgcG9seWdvblxuICAgIC8vIChubyBoZXVyaXN0aWMgaXMgdXNlZCB0byBwaWNrIGEgZ29vZCBzcGxpdCkuXG4gICAgYnVpbGQocG9seWdvbnMpIHtcbiAgICAgICAgaWYgKCFwb2x5Z29ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5wbGFuZSlcbiAgICAgICAgICAgIHRoaXMucGxhbmUgPSBwb2x5Z29uc1swXS5wbGFuZS5jbG9uZSgpO1xuICAgICAgICBjb25zdCBmcm9udCA9IFtdLCBiYWNrID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucGxhbmUuc3BsaXRQb2x5Z29uKHBvbHlnb25zW2ldLCB0aGlzLnBvbHlnb25zLCB0aGlzLnBvbHlnb25zLCBmcm9udCwgYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb250Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZyb250KVxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbnQgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5mcm9udC5idWlsZChmcm9udCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFjaylcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2sgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrLmJ1aWxkKGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/Node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/Plane.js":
/*!****************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/Plane.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Plane: () => (/* binding */ Plane)\n/* harmony export */ });\n/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Polygon.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Vector.js\");\n\n\n/**\n * Represents a plane in 3D space.\n */\nclass Plane {\n    constructor(normal, w) {\n        this.normal = normal;\n        this.w = w;\n        this.normal = normal;\n        this.w = w;\n    }\n    clone() {\n        return new Plane(this.normal.clone(), this.w);\n    }\n    flip() {\n        this.normal.negate();\n        this.w = -this.w;\n    }\n    // Split `polygon` by this plane if needed, then put the polygon or polygon\n    // fragments in the appropriate lists. Coplanar polygons go into either\n    // `coplanarFront` or `coplanarBack` depending on their orientation with\n    // respect to this plane. Polygons in front or in back of this plane go into\n    // either `front` or `back`.\n    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n        const COPLANAR = 0;\n        const FRONT = 1;\n        const BACK = 2;\n        const SPANNING = 3;\n        // Classify each point as well as the entire polygon into one of the above\n        // four classes.\n        let polygonType = 0;\n        const types = [];\n        for (let i = 0; i < polygon.vertices.length; i++) {\n            const t = this.normal.dot(polygon.vertices[i].pos) - this.w;\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n            polygonType |= type;\n            types.push(type);\n        }\n        // Put the polygon in the correct list, splitting it when necessary.\n        switch (polygonType) {\n            case COPLANAR:\n                (this.normal.dot(polygon.plane.normal) > 0\n                    ? coplanarFront\n                    : coplanarBack).push(polygon);\n                break;\n            case FRONT:\n                front.push(polygon);\n                break;\n            case BACK:\n                back.push(polygon);\n                break;\n            case SPANNING: {\n                const f = [], b = [];\n                for (let i = 0; i < polygon.vertices.length; i++) {\n                    const j = (i + 1) % polygon.vertices.length;\n                    const ti = types[i], tj = types[j];\n                    const vi = polygon.vertices[i], vj = polygon.vertices[j];\n                    if (ti != BACK)\n                        f.push(vi);\n                    if (ti != FRONT)\n                        b.push(ti != BACK ? vi.clone() : vi);\n                    if ((ti | tj) == SPANNING) {\n                        const t = (this.w - this.normal.dot(vi.pos)) /\n                            this.normal.dot(new _Vector__WEBPACK_IMPORTED_MODULE_1__.Vector().copy(vj.pos).sub(vi.pos));\n                        const v = vi.interpolate(vj, t);\n                        f.push(v);\n                        b.push(v.clone());\n                    }\n                }\n                if (f.length >= 3)\n                    front.push(new _Polygon__WEBPACK_IMPORTED_MODULE_0__.Polygon(f, polygon.shared));\n                if (b.length >= 3)\n                    back.push(new _Polygon__WEBPACK_IMPORTED_MODULE_0__.Polygon(b, polygon.shared));\n                break;\n            }\n        }\n    }\n    static fromPoints(a, b, c) {\n        const n = new _Vector__WEBPACK_IMPORTED_MODULE_1__.Vector()\n            .copy(b)\n            .sub(a)\n            .cross(new _Vector__WEBPACK_IMPORTED_MODULE_1__.Vector().copy(c).sub(a))\n            .normalize();\n        return new Plane(n.clone(), n.dot(a));\n    }\n}\nPlane.EPSILON = 1e-5;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vUGxhbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ0Y7QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQU87QUFDMUM7QUFDQSxrQ0FBa0MsNkNBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBTTtBQUM1QjtBQUNBO0FBQ0EsdUJBQXVCLDJDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8zZF9ib3hfZGVzaWduLy4vbm9kZV9tb2R1bGVzL3RocmVlLWNzZy10cy9saWIvZXNtL1BsYW5lLmpzP2VhYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQgeyBWZWN0b3IgfSBmcm9tICcuL1ZlY3Rvcic7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwbGFuZSBpbiAzRCBzcGFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYW5lIHtcbiAgICBjb25zdHJ1Y3Rvcihub3JtYWwsIHcpIHtcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFuZSh0aGlzLm5vcm1hbC5jbG9uZSgpLCB0aGlzLncpO1xuICAgIH1cbiAgICBmbGlwKCkge1xuICAgICAgICB0aGlzLm5vcm1hbC5uZWdhdGUoKTtcbiAgICAgICAgdGhpcy53ID0gLXRoaXMudztcbiAgICB9XG4gICAgLy8gU3BsaXQgYHBvbHlnb25gIGJ5IHRoaXMgcGxhbmUgaWYgbmVlZGVkLCB0aGVuIHB1dCB0aGUgcG9seWdvbiBvciBwb2x5Z29uXG4gICAgLy8gZnJhZ21lbnRzIGluIHRoZSBhcHByb3ByaWF0ZSBsaXN0cy4gQ29wbGFuYXIgcG9seWdvbnMgZ28gaW50byBlaXRoZXJcbiAgICAvLyBgY29wbGFuYXJGcm9udGAgb3IgYGNvcGxhbmFyQmFja2AgZGVwZW5kaW5nIG9uIHRoZWlyIG9yaWVudGF0aW9uIHdpdGhcbiAgICAvLyByZXNwZWN0IHRvIHRoaXMgcGxhbmUuIFBvbHlnb25zIGluIGZyb250IG9yIGluIGJhY2sgb2YgdGhpcyBwbGFuZSBnbyBpbnRvXG4gICAgLy8gZWl0aGVyIGBmcm9udGAgb3IgYGJhY2tgLlxuICAgIHNwbGl0UG9seWdvbihwb2x5Z29uLCBjb3BsYW5hckZyb250LCBjb3BsYW5hckJhY2ssIGZyb250LCBiYWNrKSB7XG4gICAgICAgIGNvbnN0IENPUExBTkFSID0gMDtcbiAgICAgICAgY29uc3QgRlJPTlQgPSAxO1xuICAgICAgICBjb25zdCBCQUNLID0gMjtcbiAgICAgICAgY29uc3QgU1BBTk5JTkcgPSAzO1xuICAgICAgICAvLyBDbGFzc2lmeSBlYWNoIHBvaW50IGFzIHdlbGwgYXMgdGhlIGVudGlyZSBwb2x5Z29uIGludG8gb25lIG9mIHRoZSBhYm92ZVxuICAgICAgICAvLyBmb3VyIGNsYXNzZXMuXG4gICAgICAgIGxldCBwb2x5Z29uVHlwZSA9IDA7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMubm9ybWFsLmRvdChwb2x5Z29uLnZlcnRpY2VzW2ldLnBvcykgLSB0aGlzLnc7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdCA8IC1QbGFuZS5FUFNJTE9OID8gQkFDSyA6IHQgPiBQbGFuZS5FUFNJTE9OID8gRlJPTlQgOiBDT1BMQU5BUjtcbiAgICAgICAgICAgIHBvbHlnb25UeXBlIHw9IHR5cGU7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1dCB0aGUgcG9seWdvbiBpbiB0aGUgY29ycmVjdCBsaXN0LCBzcGxpdHRpbmcgaXQgd2hlbiBuZWNlc3NhcnkuXG4gICAgICAgIHN3aXRjaCAocG9seWdvblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ09QTEFOQVI6XG4gICAgICAgICAgICAgICAgKHRoaXMubm9ybWFsLmRvdChwb2x5Z29uLnBsYW5lLm5vcm1hbCkgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gY29wbGFuYXJGcm9udFxuICAgICAgICAgICAgICAgICAgICA6IGNvcGxhbmFyQmFjaykucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRlJPTlQ6XG4gICAgICAgICAgICAgICAgZnJvbnQucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQkFDSzpcbiAgICAgICAgICAgICAgICBiYWNrLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNQQU5OSU5HOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IFtdLCBiID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGogPSAoaSArIDEpICUgcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpID0gdHlwZXNbaV0sIHRqID0gdHlwZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpID0gcG9seWdvbi52ZXJ0aWNlc1tpXSwgdmogPSBwb2x5Z29uLnZlcnRpY2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGkgIT0gQkFDSylcbiAgICAgICAgICAgICAgICAgICAgICAgIGYucHVzaCh2aSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aSAhPSBGUk9OVClcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCh0aSAhPSBCQUNLID8gdmkuY2xvbmUoKSA6IHZpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aSB8IHRqKSA9PSBTUEFOTklORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9ICh0aGlzLncgLSB0aGlzLm5vcm1hbC5kb3QodmkucG9zKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsLmRvdChuZXcgVmVjdG9yKCkuY29weSh2ai5wb3MpLnN1Yih2aS5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2aS5pbnRlcnBvbGF0ZSh2aiwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2godi5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZi5sZW5ndGggPj0gMylcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQucHVzaChuZXcgUG9seWdvbihmLCBwb2x5Z29uLnNoYXJlZCkpO1xuICAgICAgICAgICAgICAgIGlmIChiLmxlbmd0aCA+PSAzKVxuICAgICAgICAgICAgICAgICAgICBiYWNrLnB1c2gobmV3IFBvbHlnb24oYiwgcG9seWdvbi5zaGFyZWQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBvaW50cyhhLCBiLCBjKSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVmVjdG9yKClcbiAgICAgICAgICAgIC5jb3B5KGIpXG4gICAgICAgICAgICAuc3ViKGEpXG4gICAgICAgICAgICAuY3Jvc3MobmV3IFZlY3RvcigpLmNvcHkoYykuc3ViKGEpKVxuICAgICAgICAgICAgLm5vcm1hbGl6ZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFBsYW5lKG4uY2xvbmUoKSwgbi5kb3QoYSkpO1xuICAgIH1cbn1cblBsYW5lLkVQU0lMT04gPSAxZS01O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/Plane.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/Polygon.js":
/*!******************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/Polygon.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polygon: () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _Plane__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Plane */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Plane.js\");\n\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop. They do not have to be `Vertex`\n * instances but they must behave similarly (duck typing can be used for\n * customization).\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color).\n */\nclass Polygon {\n    constructor(vertices, shared) {\n        this.vertices = vertices;\n        this.shared = shared;\n        this.plane = _Plane__WEBPACK_IMPORTED_MODULE_0__.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n    }\n    clone() {\n        return new Polygon(this.vertices.map((v) => v.clone()), this.shared);\n    }\n    flip() {\n        this.vertices.reverse().map((v) => v.flip());\n        this.plane.flip();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vUG9seWdvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlDQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzNkX2JveF9kZXNpZ24vLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vUG9seWdvbi5qcz8xZTVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsYW5lIH0gZnJvbSAnLi9QbGFuZSc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb252ZXggcG9seWdvbi4gVGhlIHZlcnRpY2VzIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIHBvbHlnb24gbXVzdFxuICogYmUgY29wbGFuYXIgYW5kIGZvcm0gYSBjb252ZXggbG9vcC4gVGhleSBkbyBub3QgaGF2ZSB0byBiZSBgVmVydGV4YFxuICogaW5zdGFuY2VzIGJ1dCB0aGV5IG11c3QgYmVoYXZlIHNpbWlsYXJseSAoZHVjayB0eXBpbmcgY2FuIGJlIHVzZWQgZm9yXG4gKiBjdXN0b21pemF0aW9uKS5cbiAqXG4gKiBFYWNoIGNvbnZleCBwb2x5Z29uIGhhcyBhIGBzaGFyZWRgIHByb3BlcnR5LCB3aGljaCBpcyBzaGFyZWQgYmV0d2VlbiBhbGxcbiAqIHBvbHlnb25zIHRoYXQgYXJlIGNsb25lcyBvZiBlYWNoIG90aGVyIG9yIHdlcmUgc3BsaXQgZnJvbSB0aGUgc2FtZSBwb2x5Z29uLlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBkZWZpbmUgcGVyLXBvbHlnb24gcHJvcGVydGllcyAoc3VjaCBhcyBzdXJmYWNlIGNvbG9yKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvbHlnb24ge1xuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBzaGFyZWQpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICB0aGlzLnNoYXJlZCA9IHNoYXJlZDtcbiAgICAgICAgdGhpcy5wbGFuZSA9IFBsYW5lLmZyb21Qb2ludHModmVydGljZXNbMF0ucG9zLCB2ZXJ0aWNlc1sxXS5wb3MsIHZlcnRpY2VzWzJdLnBvcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24odGhpcy52ZXJ0aWNlcy5tYXAoKHYpID0+IHYuY2xvbmUoKSksIHRoaXMuc2hhcmVkKTtcbiAgICB9XG4gICAgZmxpcCgpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5yZXZlcnNlKCkubWFwKCh2KSA9PiB2LmZsaXAoKSk7XG4gICAgICAgIHRoaXMucGxhbmUuZmxpcCgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/Polygon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/Vector.js":
/*!*****************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/Vector.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: () => (/* binding */ Vector)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n/**\n * Represents a 3D vector.\n */\nclass Vector {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    }\n    clone() {\n        return new Vector(this.x, this.y, this.z);\n    }\n    negate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    add(a) {\n        this.x += a.x;\n        this.y += a.y;\n        this.z += a.z;\n        return this;\n    }\n    sub(a) {\n        this.x -= a.x;\n        this.y -= a.y;\n        this.z -= a.z;\n        return this;\n    }\n    times(a) {\n        this.x *= a;\n        this.y *= a;\n        this.z *= a;\n        return this;\n    }\n    dividedBy(a) {\n        this.x /= a;\n        this.y /= a;\n        this.z /= a;\n        return this;\n    }\n    lerp(a, t) {\n        return this.add(new Vector().copy(a).sub(this).times(t));\n    }\n    unit() {\n        return this.dividedBy(this.length());\n    }\n    length() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n    }\n    normalize() {\n        return this.unit();\n    }\n    cross(b) {\n        const a = this.clone();\n        const ax = a.x, ay = a.y, az = a.z;\n        const bx = b.x, by = b.y, bz = b.z;\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n        return this;\n    }\n    dot(b) {\n        return this.x * b.x + this.y * b.y + this.z * b.z;\n    }\n    toVector3() {\n        return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x, this.y, this.z);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vVmVjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFPO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8zZF9ib3hfZGVzaWduLy4vbm9kZV9tb2R1bGVzL3RocmVlLWNzZy10cy9saWIvZXNtL1ZlY3Rvci5qcz82NmVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSAzRCB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDApIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICB9XG4gICAgY29weSh2KSB7XG4gICAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgICB0aGlzLnogPSB2Lno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgdGhpcy54ICo9IC0xO1xuICAgICAgICB0aGlzLnkgKj0gLTE7XG4gICAgICAgIHRoaXMueiAqPSAtMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZChhKSB7XG4gICAgICAgIHRoaXMueCArPSBhLng7XG4gICAgICAgIHRoaXMueSArPSBhLnk7XG4gICAgICAgIHRoaXMueiArPSBhLno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWIoYSkge1xuICAgICAgICB0aGlzLnggLT0gYS54O1xuICAgICAgICB0aGlzLnkgLT0gYS55O1xuICAgICAgICB0aGlzLnogLT0gYS56O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGltZXMoYSkge1xuICAgICAgICB0aGlzLnggKj0gYTtcbiAgICAgICAgdGhpcy55ICo9IGE7XG4gICAgICAgIHRoaXMueiAqPSBhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGl2aWRlZEJ5KGEpIHtcbiAgICAgICAgdGhpcy54IC89IGE7XG4gICAgICAgIHRoaXMueSAvPSBhO1xuICAgICAgICB0aGlzLnogLz0gYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxlcnAoYSwgdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQobmV3IFZlY3RvcigpLmNvcHkoYSkuc3ViKHRoaXMpLnRpbWVzKHQpKTtcbiAgICB9XG4gICAgdW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlZEJ5KHRoaXMubGVuZ3RoKCkpO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54LCAyKSArIE1hdGgucG93KHRoaXMueSwgMikgKyBNYXRoLnBvdyh0aGlzLnosIDIpKTtcbiAgICB9XG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bml0KCk7XG4gICAgfVxuICAgIGNyb3NzKGIpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcbiAgICAgICAgY29uc3QgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcbiAgICAgICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgICAgIHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgICAgICB0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRvdChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiBiLnggKyB0aGlzLnkgKiBiLnkgKyB0aGlzLnogKiBiLno7XG4gICAgfVxuICAgIHRvVmVjdG9yMygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/Vector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/Vertex.js":
/*!*****************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/Vertex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vertex: () => (/* binding */ Vertex)\n/* harmony export */ });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/Vector.js\");\n\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `CSG.Vertex`. This class provides `normal` so convenience\n * functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n */\nclass Vertex {\n    constructor(pos, normal, uv, color) {\n        this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vector().copy(pos);\n        this.normal = new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vector().copy(normal);\n        this.uv = new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vector().copy(uv);\n        this.uv.z = 0;\n        color && (this.color = new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vector().copy(color));\n    }\n    clone() {\n        return new Vertex(this.pos, this.normal, this.uv, this.color);\n    }\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\n    // orientation of a polygon is flipped.\n    flip() {\n        this.normal.negate();\n    }\n    // Create a new vertex between this vertex and `other` by linearly\n    // interpolating all properties using a parameter of `t`. Subclasses should\n    // override this to interpolate additional properties.\n    interpolate(other, t) {\n        return new Vertex(this.pos.clone().lerp(other.pos, t), this.normal.clone().lerp(other.normal, t), this.uv.clone().lerp(other.uv, t), this.color && other.color && this.color.clone().lerp(other.color, t));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vVmVydGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsMkNBQU07QUFDN0IsMEJBQTBCLDJDQUFNO0FBQ2hDLHNCQUFzQiwyQ0FBTTtBQUM1QjtBQUNBLG1DQUFtQywyQ0FBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzNkX2JveF9kZXNpZ24vLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vVmVydGV4LmpzPzJiYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yIH0gZnJvbSAnLi9WZWN0b3InO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdmVydGV4IG9mIGEgcG9seWdvbi4gVXNlIHlvdXIgb3duIHZlcnRleCBjbGFzcyBpbnN0ZWFkIG9mIHRoaXNcbiAqIG9uZSB0byBwcm92aWRlIGFkZGl0aW9uYWwgZmVhdHVyZXMgbGlrZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCB2ZXJ0ZXhcbiAqIGNvbG9ycy4gQ3VzdG9tIHZlcnRleCBjbGFzc2VzIG5lZWQgdG8gcHJvdmlkZSBhIGBwb3NgIHByb3BlcnR5IGFuZCBgY2xvbmUoKWAsXG4gKiBgZmxpcCgpYCwgYW5kIGBpbnRlcnBvbGF0ZSgpYCBtZXRob2RzIHRoYXQgYmVoYXZlIGFuYWxvZ291cyB0byB0aGUgb25lc1xuICogZGVmaW5lZCBieSBgQ1NHLlZlcnRleGAuIFRoaXMgY2xhc3MgcHJvdmlkZXMgYG5vcm1hbGAgc28gY29udmVuaWVuY2VcbiAqIGZ1bmN0aW9ucyBsaWtlIGBDU0cuc3BoZXJlKClgIGNhbiByZXR1cm4gYSBzbW9vdGggdmVydGV4IG5vcm1hbCwgYnV0IGBub3JtYWxgXG4gKiBpcyBub3QgdXNlZCBhbnl3aGVyZSBlbHNlLlxuICovXG5leHBvcnQgY2xhc3MgVmVydGV4IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG5vcm1hbCwgdXYsIGNvbG9yKSB7XG4gICAgICAgIHRoaXMucG9zID0gbmV3IFZlY3RvcigpLmNvcHkocG9zKTtcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgVmVjdG9yKCkuY29weShub3JtYWwpO1xuICAgICAgICB0aGlzLnV2ID0gbmV3IFZlY3RvcigpLmNvcHkodXYpO1xuICAgICAgICB0aGlzLnV2LnogPSAwO1xuICAgICAgICBjb2xvciAmJiAodGhpcy5jb2xvciA9IG5ldyBWZWN0b3IoKS5jb3B5KGNvbG9yKSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlcnRleCh0aGlzLnBvcywgdGhpcy5ub3JtYWwsIHRoaXMudXYsIHRoaXMuY29sb3IpO1xuICAgIH1cbiAgICAvLyBJbnZlcnQgYWxsIG9yaWVudGF0aW9uLXNwZWNpZmljIGRhdGEgKGUuZy4gdmVydGV4IG5vcm1hbCkuIENhbGxlZCB3aGVuIHRoZVxuICAgIC8vIG9yaWVudGF0aW9uIG9mIGEgcG9seWdvbiBpcyBmbGlwcGVkLlxuICAgIGZsaXAoKSB7XG4gICAgICAgIHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgdmVydGV4IGJldHdlZW4gdGhpcyB2ZXJ0ZXggYW5kIGBvdGhlcmAgYnkgbGluZWFybHlcbiAgICAvLyBpbnRlcnBvbGF0aW5nIGFsbCBwcm9wZXJ0aWVzIHVzaW5nIGEgcGFyYW1ldGVyIG9mIGB0YC4gU3ViY2xhc3NlcyBzaG91bGRcbiAgICAvLyBvdmVycmlkZSB0aGlzIHRvIGludGVycG9sYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAgICBpbnRlcnBvbGF0ZShvdGhlciwgdCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlcnRleCh0aGlzLnBvcy5jbG9uZSgpLmxlcnAob3RoZXIucG9zLCB0KSwgdGhpcy5ub3JtYWwuY2xvbmUoKS5sZXJwKG90aGVyLm5vcm1hbCwgdCksIHRoaXMudXYuY2xvbmUoKS5sZXJwKG90aGVyLnV2LCB0KSwgdGhpcy5jb2xvciAmJiBvdGhlci5jb2xvciAmJiB0aGlzLmNvbG9yLmNsb25lKCkubGVycChvdGhlci5jb2xvciwgdCkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/Vertex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-csg-ts/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/three-csg-ts/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSG: () => (/* reexport safe */ _CSG__WEBPACK_IMPORTED_MODULE_0__.CSG)\n/* harmony export */ });\n/* harmony import */ var _CSG__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CSG */ \"(ssr)/./node_modules/three-csg-ts/lib/esm/CSG.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY3NnLXRzL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8zZF9ib3hfZGVzaWduLy4vbm9kZV9tb2R1bGVzL3RocmVlLWNzZy10cy9saWIvZXNtL2luZGV4LmpzPzgwYTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9DU0cnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-csg-ts/lib/esm/index.js\n");

/***/ })

};
;